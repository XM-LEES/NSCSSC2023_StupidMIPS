# 数据结构和算法绪论

### 逻辑结构和物理结构

- 逻辑结构：数据对象中数据元素之间的相互关系
  - 集合结构：属同一集合，无其他关系
  - 线性结构：一对一关系
  - 树形结构：存在一对多（金字塔）
  - 图形结构：多对多关系
- 物理结构：数据的逻辑结构在计算机中的存储形式，即如何把数据元素存储到计算机的存储器中，存储器针对内存而言（硬盘软盘     光盘）
  - 顺序存储：把数据元素存放在地址连续的存储单元，其数据间的逻辑和物理关系一致
    - eg：数组 1-2-3-4
  - 链式存储：把数据元素存放在任意存储单元，这组单元可以连续也可不连续。存储关系不能反映其逻辑关系，需要额外用一个指针存放数据元素地址
    - eg：链表

## 01-A算法

- 解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作
- <u>特征</u>：
  - ==输入==：算法具有零个或多个输入
  - ==输出==：算法至少有一个或多个输出。形式可以是打印，也可返回一或多个值
  - ==有穷性==：执行有限的步骤后，自动结束不会出现无限循环，每一个步骤在可接受的时间内完成
  - ==确定性==：算法的每一个步骤具有确定的含义，不会出现二义性；在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果；每个步骤都应该被精确定义而无歧义
  - ==可行性==：算法每一步都必须是可行的，即每一步都能够通过执行有限次数完成
- 算法设计的要求（<u>好算法</u>）：
  - ==正确性==：至少具有输入输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案
    - 算法程序没有语法错误
    - 算法程序对于合法输入能够产生满足要求的输入
    - 算法程序对于非法输入能够产生满足规格的说明
    - 算法程序对于故意刁难的测试输入都有满足要求的输出结果
  - ==可读性==：便于阅读理解和交流
  - ==健壮性==：输入数据不合法时，能做出相关处理，不是产生异常、崩溃或其他结果
  - 时间==效率==高和存储量低



### 时间复杂度和空间复杂度

通常用时间复杂度来指运行时间的需求，用空间复杂度指空间需求，直接求复杂度时，通常指的是时间复杂度。

### 算法效率的度量方法

- 研究算法的复杂度，侧重的是研究算法随着输入规模扩大增长量的一个抽象，并非精确定位需要执行多少次。

  不计那些循环索引的递增和循环终止条件，变量声明打印结果等操作。最终在分析程序的运行时间时，把程序看成是独立于程序设计语言的算法或一系列步骤。

  分析一个算法的运行时间时，重要的是把基本操作的数量和输入模式关联起来

- 事后统计方法：通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，确定算法效率的高低

- 事前分析估算方法：在计算机程序编写前，依据统计方法对算法进行估算
  - 高级语言编写的程序在计算机上运行时消耗的时间取决于下列因素：
    1. 算法采用的策略、方案
    2. 编译产生的代码质量
    3. 问题的输入规模
    4. 机器执行指令的速度
  
- 函数的渐进增长：给定两个函数f（n）和g（n），如果存在一个整数N，使得对于所有n>N，f（n）总是比g（n）大，那么f（n）的增长渐进快于g（n）
  - 判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注最高项的阶数
    - eg：3n+1 ; 2n^2 ; 2n^3+3n+1

### 算法的时间复杂度

- 定义：在进行算法分析时，语句总的执行次数T（n）是关于==问题规模n==的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级。

  ps：一般关注最坏情况

  - 记作T（n）=O（f（n）），表示随问题规模n的增大，算法执行时间的增长率和f（n）的<u>增长率</u>相同，称作算法的渐时间复杂度，简称时间复杂度。f（n）是问题规模n的某个函数。（执行次数==时间）
    - eg ：O（1）；O（n）；O（n^2）

### 算法的空间复杂度

- 通过计算算法所需的存储空间实现，计算公式：S（n）=O（f（n）），其中n为问题的规模，f（n）为语句关于n所占存储空间的函数
- 计量空间不考虑输入

## 01-B补充：图灵机模型 RAM模型

![image-20220724101016111](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220724101016111.png)![image-20220724101518039](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220724101518039.png)

![image-20220724102249324](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220724102249324.png)![image-20220724102706149](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220724102706149.png)

## 01-C算法时间复杂度度量

### 大O记号

- 推导O阶方法——==**大O攻略**==
  - 用常数1取代运行时间中的所有加法常数
  - 在修改后的运行次数函数中，只保留最高阶项
  - 如果最高阶项存在且不是1，去除前面常数
    - 常数项可忽略
    - 低次项可忽略
- 常见时间复杂度实例：

  - 线性阶O（n）：一般==含有非嵌套循环==涉及线性阶，随着问题规模n的 增大，对应计算次数呈直线增长

  - 平方阶O（n^ 2）：==嵌套循环==（三个嵌套O（n^3））<u>循环的时间复杂度=循环体的复杂度*循环运行的次数</u>

	  - ```c
      //特殊情况
      int i, j, n = 100;
      for(i = 0; i < n; i++ )
      {
        for(j = i; j < n; j++)
        {
            printf("hello world");
        }
      }
      //总执行次数:n（外）   +   (n-1)+...+1 = n(n-1)/2 => n^2
      ```
    
  - 对数阶O（logn）：每次i*2后，距离n更进一步，假设x个2相乘后大于等于n。由2^x = n得x=log(2)n，时间复杂度为O（logn）
  
    - ```c
      int i = 1, n = 100;
      while( i < n )
      {
      i = i * 2;
      }
      ```
    
  - 函数调用的时间复杂度：关注function（）
  
    - ```c
      n++;						//1
      function(n);				//n
      for(i =0; i < n; i++){		//n^2
      	function(i);
      }
      for(i = 0; i < n; i++){		//n^2
          for(j = i; j < n; j++){
              printf("%d", j);
          }
      }
      void function(int count){
          int j;
          for(j = count; j < n; j++){
              printf("%d", j);
          }
      }
      ```

| 例子           | 时间复杂度 | 类型    |
| -------------- | ---------- | ------- |
| 常数C          | O（1）     | 常数阶  |
| 3n+4           | O（n）     | 线性阶  |
| 3n^2+4n+5      | O（n^2）   | 平方阶  |
| 3log(2)n+4     | O（logn）  | 对数阶  |
| 2n+3nlog(2)n+4 | O（nlogn） | nlogn阶 |
| n^3 +2n^2+4n+6 | O（n^3）   | 立方阶  |
| 2^n            | O（2^n）   | 指数阶  |

- 常用时间复杂度顺序：

<u>O（1）</u><  <u>O（logn）</u><  <u>O（n）</u><  <u>O（nlogn）</u><  <u>O（n^2）</u><  O（n^3）<  O（2^n）<  O（n!）<  O（n^n）

从O（n^c ）到O（2^n）是有效算法到无效算法的分水岭

- 最坏情况与平均情况
  - 最坏情况：是一种保证，通常除非特别指定，提到的运行时间都是最坏情况的运行时间
  - 平均运行时间：期望的运行时间

### 其他记号

最好情况估计：Ω ；准确估计：θ![image-20220724132815561](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220724132815561.png)

## 01-D算法分析

- 主要任务：正确性（不变性x单调性）+复杂度

- c++等高级语言的基本指令，均等效于常数条RAM的基本指令，在渐近意义下，而这大体相当
  - 分支转向：goto  //出于结构化考虑被隐藏
  - 迭代循环：for（）、while（）.... //本质上是“if + goto”
  - 调用+递归（自我调用）//本质上也是goto
  
- 复杂度分析主要方法：
  - 迭代：级数求和
  - 递归：递归跟踪+递推方程
  - 猜测+验证
  
- 封底分析（封底估算）

  1天 = 24 hr x 60 min x 60 sec = 25 x 4000 = 10^5^sec

  1世纪 = 100 yr x 365 = 3 x 10^4^day = 3 x 10^9^sec

  三生三世 = 300 yr = 10^10^sec

### 01-d迭代计算复杂度：级数求和

- 算术级数：与末项平方同阶

  T（n）= 1+2+3+...n = n（n+1）/2=O（n^2）

- 幂方级数：比幂次高出一阶

  ![image-20220724142203588](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220724142203588.png)

- 几何级数：与末项同阶

  ![image-20220724162918684](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220724162918684.png)

- 收敛级数：O（1）![image-20220724163039162](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220724163039162.png)![image-20220724164947192](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220724164947192.png)

- 未必收敛，长度有限（以下两个常用）![image-20220724164550832](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220724164550832.png)

  ​	（strling公式）

实例：

![image-20220725095836141](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220725095836141.png)

![image-20220725095800929](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220725095800929.png)

注：上图几何级数例子

![image-20220725101153752](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220725101153752.png)

取非极端元素，起泡排序 ppt

eg：起泡排序分析：
![image-20220725143843621](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220725143843621.png)
![image-20220725143757793](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220725143757793.png)

- 不变性：经k轮扫描后，最大的k个元素必然就位
- 单调性：经k轮扫描后，问题规模缩减为n-k
- 正确性：经过至多n轮扫描后，算法必然终止，且能给出正确答案

==注：分析算法不变性和单调性进而得出正确性的方法==

### 01-e递归计算复杂度：递归跟踪/递推

#### 减而治之：

  - 为求解一个大规模的问题，将其划分为两个子问题，其一平凡，另一规模缩减。
  - 分别求解子问题
  - 由子问题的解，得到原问题的解

![image-20220725151454873](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220725151454873.png)

- 实例1：数组求和

  <img src="D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220725152951955.png" alt="image-20220725152951955" style="zoom:40%;" />

```c
//数组求和——线性递归 O（n）
sum(int A[], int n){
    return (n < 1) ? 0 : sum(A, n-1) + A[n-1];
}
//数组求和——迭代 O（n）
sum(int A[], int n){
    int sum = 0
    for(int i = 0; i < n; i++)
    {
        sum = sum + A[i];
    }
}
```

递归跟踪：

- 检查每个==递归实例==累计所需时间（调用语句本身，计入对应的子实例，O（1）通常 抹掉不计），总和即算法执行时间
  - 应用范围有限，一般适合简单的线性递归（实例1）

递推角度：

- 为求解sum(A, n)【T(n)】，需要递归求解规模为n-1的问题sum(A, n-1)【T(n-1)】再累加上A[n-1]【O(1)】，递归基sum(A, 0)【O(1)】
  - 递推关系：T(n) = T(n-1) + O(1)    T(0 ) = O(1)
  - 方程同减n
    T(n) - n = T(n-1) - (n-1) = ... 
    		 = T(2) - (2) = T(1) - (1) = T(0) 
    T(n) = O(n)



- 实例2：数组倒置

统一接口：void reverse（int* A，int lo， int hi）；

```c
//递归版   O(n)
if(lo < hi){
    swap(A[lo], A[hi]);
    reserve(A, lo + 1, hi - 1);
}
else if(lo >= hi) return;
    
//迭代版
next:
	if(lo < hi){
	    swap(A[lo], A[hi]);
    	lo++;hi++;goto next;
}
//迭代精简版
while(lo < hi)
    swap(A[lo++], A[hi--]);
```

#### 分而治之:

- 为求解一个大规模的问题，可以将其划分为若干（通常两个）子问题，规模大体相当
- 分别求解子问题
- 由子问题的解，得到原问题的解

![image-20220725183222532](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220725183222532.png)



- **<u>实例1</u>**：数组求和——二分递归

![image-20220725183756484](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\image-20220725183756484.png)

```c
sum(int A[], int lo, int hi){ //区间范围A[lo, hi]
    if(lo == hi) return A[lo];
    int mi = (lo + hi) >> 1;
    return sum(A, lo, mi) + sum(A, mi + 1, hi);
}//入口形式 sum(a, 0, n-1)
```

递归跟踪分析：

​	T（n）= O(1)x(2^0^+2^1^+2^2^+...+2^log~2~ ^n^)= O(1)x(2^(log~2~ ^n^+1) -1)=O(n)

  ![image-20220725183938917](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\01-E-6 001.png)

递推分析：

- 为求解sum(A, lo, hi)，需递归求解sum(A, lo, mi)和sum(A, mi + 1, hi)，进而将子问题累加，递归基sum(A, lo, lo)
- 递推关系：T(n) = 2 x T(n/2) + c~1~	T(1) = O(1)		同加c~1~求解



- **<u>实例2</u>**：# Max 2

  从数组区间A[lo, hi)中找出最大的两个整数A[x~1~]和A[x~2~]，元素比较的次数尽可能地少

```c
//迭代方法1——扫描两次
void max2(int A[], int lo, int hi, int & x1, int & x2){
    for(x1 = lo, int i = lo + 1; i < hi; i++)	//扫描A[lo, hi)
        if(A[x1] < A[i])
            x1 = i;
    for(x2 = lo, int i = lo + 1; i < x1; i++)	//扫描A[lo, x1)
        if(A[x2] < A[i])
            x2 = i;
    for(int i = x1 + 1; i < hi; i++)			//扫描A(x1, hi)
        if(A[x2] < A[i])
            x2 = i;
}
//复杂度O(2n-3) = O(n)
//******************************************
//迭代方法2——堆排序
void max2(int A[], int lo, int hi, int & x1, int & x2){
    if(A[xi = lo] < A[x2 = lo + 1])//x1最大 x2次大
        swap(x1, x2);
    for(int i = lo + 2; i < hi; i++)
        if(A[x2] < A[i])
            if(A[x1] < A[x2 = i])
                swap(x1, x2);
}
//最好情况 1+n-2=n-1		最坏情况 1+2*(n-2)+1=2n-3
//******************************************
//递归+分治可以实质上改进
void max2(int A[], int lo, int hi, int & x1, int & x2){
    if(lo + 2 == hi){
        ？？？？？;
        return;
}										//T(2) = 1
    if(lo + 3 == hi){
        ？？？？？;
        return;
    }									//T(3) <= 3
    int mi = (lo + hi) / 2;				//divide
/*    if(lo == mi|| hi == mi)
    {
        x1 = (A[lo] > A[hi]) ? lo : hi;
        x2 = (A[lo] < A[hi]) ? lo : hi;
        return;
    }
*/
    max2(A, lo, mi, x1L, x2L);
    max2(A, mi, hi, x1R, x2R);
    if(A[x1L] > A[x1R]){
        x1 = x1L;
        x2 = (A[x2L] > A[x1R]) ? x2L : x1R;
    }
    else{
        x1 = x1R;
        x2 = (A[x2R] > A[x1L]) ? x2R : x1L;
    }									// 1 + 1 = 2
}
//最坏情况T(n) = 2*T(n) + 2 <= 5n/3 -2 ？？？？？？？？
//最好情况T(n) = 2*T(n) + 2 <= 5n/3 -2
```



<img src="D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\01-E-6 002.png" alt="image-20220725210448228" style="zoom:50%;" />

## 01-F动态规划

- 通过递归找出算法的本质，给出初步的解之后再将其等效转化为迭代

### 实例：斐波那契数列

#### fib()递归

##### 递推分析

复杂度：T(n) = T(n-1) + T(n-2) + 1，其中n>1  T(0) = T(1) = 1

​		令：S(n) = [T(n) + 1]/2

​		则：S(0) = 1 =fib(1)，S(1) = 1 = fib(2)

​		故：S(n) = S(n-1) + S(n-2) = fib(n+1)

fib(n)的第n项公式：![image-20220726104115471](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\01-f-2 001.png)=O(Φ^n^)，Φ = （1 + √5）/2 = 1.61803...

T(n) = 2 * S(n) - 1 = 2 * fib(n+1) - 1 = O(fib(n+1)) = O(Φ^n^) = O(2^n^)

注：S(n)是与复杂度相关的量，将复杂度的递推公式变换成相应的S(n)的递推公式，然后发现S(n)和fib(n)形式上一样，实际上是fib(n)往后推了一位，S(n) ==fib(n+1) 

##### 封底估算

- 近似式：

  - Φ^36^ = 2^25^ ，2^10^ = 10^3^

    Φ^43^ = 2^30^ = 10^9^ flo = 1 sec

  - Φ^5^ = 10 ，2^10^ = 10^3^

    Φ^67^ = 10^14^ flo = 10^5^ sec = 1 day

    Φ^92^ = 10^19^ flo = 10^10^ sec = 3 century

##### 递归跟踪

![image-20220726110017361](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\01-f-4 001.png)

改进方法：对每个实例只进行一次

#### fib()迭代

##### 解决方法A（记忆：memoization）

- 将已计算过实例的结果制表备查

```c
//在入口处增加对于全局表格的查询，只有表格中没有有效结果才进行实质性计算
int A[MAX] = {};
int fib(int n, int* A){
    if(n < 1)
     return 1;
    if(A[n] > 0)
        return A[n];
    else{
        A[n] = fib(n-1, A) + fib(n-2, A);
        return A[n];
    }
}
```

时间复杂度是O(n)吗？？空间复杂度为O(n)

##### 解决方法B（动态规划：dynamic programming）

- 颠倒计算方向：由自顶向下递归，改为自底向上迭代

<img src="D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\01-f-5 001.png" alt="image-20220726110802736" style="zoom:50%;" />

```c
int f = 0; g = 1;
while(0 < n--){
    g = g + f;
    f = g - f;
}
return g;
```

复杂度仅为T(n) = O(n)，而且仅需要O(1)空间！！



### 实例：最长公共子序列

- 子序列：由序列中若干字符按原相对次序构成
- 最长公共子序列(LCS: Longest Common Subsequence)：两个序列公共子序列中最长者，可能有多个，可能有歧义（结果唯一，但某个字符在某序列中位置不唯一）
- 以下只考察对于序列A[0, n]，B[0, m]最长公共子序列的长度

#### 递归

- 可能情况：

  0. 若n = -1 或m = -1，则取作空序列("")									//递归基

  1. 若A[n] = 'X' = B[m]，则取作LCS(A[0, n)，B[0, m)) +'x'        

     //去掉末字符，切分成一个平凡问题和规模减一的问题，减而治之![image-20220726144229352](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\01-f-7 001.png)

  2. 若A[n] !=  B[m]，则比较取LCS(A[0, n-1)，B[0, m))，LCS(A[0, n)，B[0, m-1))

     //分别去掉其中一个末字符，构成两个子问题，最终解为二者较大的一个，分而治之

     ![image-20220726144140814](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\01-f-7 002.png)

```c
int LCS(int *A, int n, int *B, int m){
    if(n == -1 || m == -1)
        return 0;
    if(A[n] == b[m])
        return 1 + LCS(A, n-1, B, m-1);
    else
        return LCS(A, n-1, B, m) > LCS(A, n, B, m-1) ? LCS(A, n-1, B, m) : LCS(A, n, B, m-1);
}
```

- 单调性：无论如何，每经过一次比对，原问题的规模必可减小

  具体地，作为输入的两个序列，至少其一的长度缩短一个单位

- 最好情况（只出现减而治之，不出现2），每一个递归实例都会缩减为1个递归实例，所对应的序列也会单调减少1个单位，至多只需O(n+m)时间

- 糟糕情况（分而治之出现），原来问题分解为两个子问题，规模之和大致为原来的两倍，随后进一步导出的子问题，可能雷同（指多个递归实例共同唤醒公共的实例）

  复杂度 m=n时，O(2^n^)——图解右下到左上

#### 迭代

- 与fib()类似，有大量重复的递归实例（子问题），最坏情况出现O(2^n^)个

- 各子问题分别唯一对应AB的某个前缀组合，总数共n*m种

- 采用动态规划策略，只需O(n*m)时间即可计算出所有子问题    由递归改为迭代

  - 将所有子问题（假象地）列成一张表
  - 颠倒计算方向，从LCS(A[0], B[0])出发依次计算所有项（左上到右下）

  ![image-20220726165147429](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\01-f-9 001.png)

------



# 02向量

向量、列表同属线性性序列

## 数据结构与抽象数据类型

- 本章讨论：

  1. ADT~抽象数据类型~/implementation~实现~如何根据统一的接口形式，定制实现一个数据结构
  2. Algorithms~算法~{search   sorting}如何通过更加有效的算法，使得对外的接口能够更加高效地工作（包括查找、排序算法）

- 抽象数据类型~Abstract-Data-Type~ 与数据结构~Data-Structure~辨析：

  ![image-20220726170308829](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-A-1 001.png)

## 向量ADT

- 向量：c/c++语言中，==数组==这种数据组织形式的一种推广和泛化

  - 数组A[]中的元素（每一个旦元）与[0, n)内的编号一一对应

  - 每个元素均由（非负）编号唯一指代，并可直接访问

    A[i]物理地址 = A + i x s，s为单个元素占用的空间量

    所有元素的物理地址可以通过线性的方程来确定，故称作线性数组（linear array）

- 向量是数组的抽象与泛化，由一组元素按线性次序封装而成

  - 各个元素与[0, n)内的==秩==（rank）一一对应		//寻秩访问（call-ny-rank）
  - 元素的==类型不限于基本类型==
  - 操作、管理维护更加简化、统一与安全
  - 可更为便捷地参与==复杂数据结构==的定制与实现

### 向量ADT接口

- 按照抽象数据类型规范，向量结构必须提供一系列的操作接口，对向量进行操作

![0](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-A-2 001.png)

- ADT操作实例

![image-20220726174131076](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-A-3 001.png)

## 模板——以Vector为例

### 数据结构定义的通用方法——模板

- 通过模板式的方法，可以使数据结构定义非常规范，之间可以互相组合，便捷的搭建更加复杂的数据结构

```c++
//大致格式
template/*以template引导*/ < typename/*关键词*/T/*模板参数，用于指定Vector结构中所有元素的类型*/ > Vector/*数据结构名字*/{....};/*实现*/	

//定义了一系列的Vector，使用时可以零活指定类型
Vector< int > myVector;
Vector< float > myVector;
Vector< char > myVector;
Vector< ... > myVector;
//可以把某些数据结构作为元素构成向量
Vector< BinTree > forest;
```

- 构造与析构

```c++
typedef int Rank;//秩
#define DEFAULT_CAPACITY 3//默认初始容量(实际应用中可设置为更大)
template <typename T> class Vector{//向量模板类
    private: Rank _size; Rank _capacity; T* _elem;//规模、容量、数据区
    protected:
    /*...内部函数*/
    public:
    /*...构造函数*/
    /*...析构函数*/
    /*...只读接口*/
    /*...可写接口*/
    /*...遍历接口*/
};
```

详见[vector.h (tsinghua.edu.cn)](https://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/vector/vector.h.htm)

- 复制的构造

![image-20220726200002494](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-A-5 001.png)

复杂度取决于被复制元素个数（复制区间宽度）

## 可扩充向量

### 静态空间管理

- 不可扩充的向量采用静态空间管理策略

  即在内部开辟数组_elem[]并使用一段地址连续的物理空间_

  元素占用逻辑空间数（或者说元素个数）_size

  整个物理空间大小_capacity

- 不足：
  1. 上溢（overflow）：_elem[ ]不足以存放所有的元素
  2. 下溢（underflow）：_elem[ ]中的元素寥寥无几，装填因子（load factor） λ = _size/ _capacity <<50%

### 动态空间管理（扩容）

- (c)在即将发生上溢时，适当地扩大内部数组的容量（动态申请另一段存储空间，大小比原来有所增长）
- (d)(e)将原先存放好的有效元素逐一复制，释放原先的空间

<center class="half">    <img src="D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-B-2 001.png" width="35%"/>    <img src="D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-B-2 002.png" width="64%"/> </center>

```c++
template <typename T>
void Vector<T>::expand(){
    if (_size < _capacity) return;
    _capacity = max(_capacity, DEFAULT_CAPACITY);
    T* oldElem = _elem;
    _elem = new T[_capacity <<= 1];
    for (int i = 0; i < _size; i++)
        _elem[i] = oldElem[i];
    delete [] oldElem;
}
```

- 数组也可以通过上述思路扩容，得益于向量的封装，尽管扩容之后数据区的物理地址有所改变，却不至于出现野指针——在访问某一个元素时，内部都是通过_elem这个统一指示器来标示起点

- 容量加倍策略：

![image-20220726203431012](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-B-4 002.png)

### 平均分析vs .分摊分析

- 平均复杂的或期望复杂度（average/expected complexity）
  - 根据数据结构各种操作出现概率的分布，将对应的成本加权平均
  - 将各种可能的操作作为==独立==事件分别考察
  - 缺点：割裂了操作之间的==相关性==和==连贯性==，往往不能准确的评判数据结构和算法的真实性能
- 分摊复杂度（amortized complexity）
  - 对于数据结构和==连续地==实施==足够多==次操作，所需总体成本分摊至单次操作
  - 从实际可行的角度，对一系列操作做整体考量
  - 更加忠实地刻画了可能出现的操作序列，可以更为精确地评判数据结构和算法的真实性能

## 无序向量

- 向量的最基本形式

### 元素访问（寻秩访问）

* 向量标准ADT中定义了==V.get(r)==和==V.put(r, e)==接口，可以读、写向量元素
  * 形式上不够简洁直观，不如数组元素的访问方式==A[r]==

- 沿用借助下标的访问方式，需==重载==下标操作符"[ ]"

```c++
template <typename T>// 0 <= r < _size
T & Vector<T>::operator[](Rank r) const { return _elem[r];}
//对于任意指定的Rank r，只需要取出下标为r的元素
//对外的v[r]即对应于内部的v._elem[r]
```

- 可作为右值：T x = V[r] + U[s] * W[t];

  可作为左值：V[r] = (T) (2*x + 3); （==得益于该接口返回值是一个**引用**???==）

- 注：本例仅有注释提醒入口参数范围，在实际应用中，应采用更严格的方式处理意外和错误（例如入口参数越界等）

### 插入

![image-20220727144300835](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-C-3 001.png)

```c++
template <typename T>//e作为秩为r元素插入 0<=r<=_size
Rank Vector<T>::insert(Rank r, T const & e){	//O(n-r)
    expand();	//若有必要，扩容
    for(int i = _size; i > r; i--)// i-- 自后向前，否则会覆盖丢失
        _elem[i] = _elem[i-1];//后继元素顺次后移一个单元
    _elem[r] = e;//置入新元素
    _size++;//更新容量
    return r;//返回秩
}
```

### 区间删除

![image-20220727145021101](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-C-4 001.png)

```c++
template <typename T>//删除区间[lo,hi)， lo <= hi <= size
int Vector<T>::remove(Rank lo, Rank hi){	//O(n - hi)
    if(lo == hi)	//出于效率考虑，单独处理退化情况
        return 0;
    while(hi < _size)
        _elem[lo++] = _elem[hi++];//[hi, _size)顺次前移hi+lo位
    _size = lo;//更新规模 （此时恰好lo = new_size，hi = old_size）
    shrink();//有必要则缩容，实际应用中非必需，可以忽略
    return hi - lo;//返回被删除元素的数目
}
```

### 查找

- 无序向量：T为可判等的基本类型，或已重载操作符“==”或“!=”

  有序向量：T为可比较的基本类型，或已重载操作符“<”或“>”

![image-20220727150847575](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-C-5 001.png)

```c++
template <typename T>// 0 <= lo <= hi <= _size
Ranke Vector<T>::find(T const & e, Rank lo, Rank hi)const
{//O(hi - lo)，在命中多个元素时返回秩最大者
    while((lo < hi--) && (e != _elem[hi]));//逆向查找！
//hi为哨兵元素 查找范围hi之前到lo的元素。--优先级高，最后能判断到_elem[lo]
    return hi;//hi < lo意味失败，否则hi即命中元素的秩
}//失败情况最后一次比较lo = hi，hi--，hi < lo
```

- 输入敏感（input-sensitive）：复杂度与输入配置相关最好O(1)，最差O(n)

### 单元素删除

- 视作区间删除操作的特例：[r] =[r, r + 1)

```c++
template <typename T>//删除向量中秩为r的元素 0 <= r < size
T Vector<T>::remove(Rank r){	//O(n - r)
    T e = _elem[r];	//备份被删除元素
    remove(r, r + 1);//调用区间删除算法
    return e;//返回被删除元素
}
```

### 唯一化

<img src="D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-C-7 001.png" alt="image-20220727162152902" style="zoom:80%;" />

```c++
template <typename T>//删除重复元素，返回被删除元素数目
int Vector<T>::deduplicate(){
    int oldSize = _size;//记录原始规模
    Rank i = 1;//从_elem[1]开始，自前向后逐一考察各元素
    while(i < _size)
        (find(_elem[i], 0, i) < 0) ?//在前缀中寻找雷同
        i++	//若无雷同继续考察其后继
        : remove(i);//否则删除雷同
    return oldSize - _size;//向量规模变化量，即删除元素总数
}
```

- 唯一化算法正确性证明
  - 不变性：在当前元素V[i]的前缀V[0, i)中，各元素彼此互异，初始i=1成立自然成立；其余情况归纳可知同样成立：1）查找失败，之前不含元素e，i+1后前缀仍不重复；2）查找成功，删除e，前缀不重复
  - 前一次迭代满足不变性，后一次迭代必然保持下去

- 单调性：
  - 当前元素前缀的长度单调非降，且迟早增至_size
  - 当前元素后缀的长度单调下降，且迟早减至0

  算法必然终止，至多迭代O(n)轮

- 唯一化算法复杂度
  
- find()操作相对前缀而言，remove()操作相对后缀而言，每次循环累计不会超过向量长度O(n)，while循环最多迭代O(n)，累计起来最坏情况O(n^2^)
  
- 算法优化

![image-20220727170205552](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-C-7 002.png)

```c++
？？？？？？？？？优化
```

### 遍历

- 遍历：按照某种事先约定的操作（visit），统一对各元素分别执行一次visit操作

如何指定visit操作？如何将其传递到内部？

1. 利用==函数指针==机制，==只读==或==局部性==修改

```c++
template <typename T>
void Vector<T>::traverse(void (*visit)(T&))//函数指针
{
 for(int i = 0; i < _size; i++)
     visit(_elem[i]);
}
```

2. 利用==函数对象==机制，可==全局性==修改//通用性更强

```c++
template <typename T> template <typename VST>
void Vector<T>::traverse(VST& visit)//函数对象
{
   for(int i = 0; i < _size; i++)
     visit(_elem[i]);
}
```

- 实例——将向量中所有元素分别加一

首先实现一个可使单个T类型元素加一的类

```c++
template <typename T>//假设T可直接递增或已重加载操作符“++”
struct Increase{//函数对象：通过重载操作符“()”实现
  virtual void operator()(T & e){e++;} //加一
} 
```

调用Vector统一的遍历接口，将上述函数对象以参数形式传入

```c++
template <typename T>
void increase(Vector<T> & V){
    v.traverse(Increase<T>());//以之为基本操作遍历向量
}
```

- 练习：实现减一，加倍，求和等遍历功能

  ```
  
  ```

## 有序向量

- 无序向量：元素之间至少能够进行比对操作
- 有序向量：能够判断一对元素孰大孰小（必要条件）

### 有序性及其甄别

- ==有序==序列中，==任意==一对相邻元素==顺序==

  ==无序==序列中，==至少==一对相邻元素==逆序==

- 相邻逆序对的数目，可以度量向量逆序程度

```c++
template <typename T>//返回逆序相邻元素对的总数
int Vectorr<T>::disordered()const{
    int n = 0;//计数器
    for(int i = 1; i < _size; i++)//逐个检查各对相邻元素
        n += (_elem[i-1] > _elem[i]);//逆序则计数
    return n;//向量有序当且仅当n = 0
}//若只需判断是否有序，则首次遇到逆序对之后，即可立即终止
```

- 只要向量中元素本身支持大小比较，则无序向量可经预处理==转换==为有序向量，相关算法多可优化

### 唯一化（有序向量）

#### 低效算法

![image-20220727200011924](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D1-2 001.png)

```c++
template <typename T>//删除重复元素，返回被删除元素数目
int Vector<T>::uniquify(){
    int oldSize = _size;//记录原始规模
    int i = 0;//从首元素开始，自前向后逐一比对各相邻元素
    while(i < _size - 1)
        (_elem[i] == _elem[i + 1]) ? remove(i + 1) : i++;//若有雷同删除后者，否则转至后一元素
    return oldSize - _size;//向量规模变化量，即删除元素总数
}//_size减小由remove()隐式完成
```

- 复杂度
  - 运行时间取决于while循环，共计次数_size-1 = n - 1
  - 最坏情况：每次调用remove()，耗时(n-1)~O(1)，累计O(n^2^)，总体与deduplicate()相同

![image-20220727201303417](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D1-3 001.png)

#### 高效算法

- 反思：问题根源，同一元素可作为被删除元素的后继多次前移
- 改进：以重复区间为单位，成批删除雷同元素

![image-20220727201858699](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D1-4 001.png)

```c++
template <typename T>//删除重复元素，返回被删除元素数目
int Vector<T>::uniquify(){
    Rank i = 0, j = 0;//各对互异元素的秩
    while(++j < _size)//逐一扫描，直到末元素
        if(_emel[i] != _elem[j])//跳过雷同者；发现不同元素时，向前移至紧邻于前者右侧
            _elem[++i] = _elem[j];
    _size = ++i;
    shrink();//直接截除尾部多余元素
    return j - i;//向量规模变化量，即删除元素总数
}//注意，通过remove(lo, hi)批量删除，依然不能达到高效率
```

- 实例与复杂度分析

![image-20220727210601502](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D1-5 001.png)

- 每次i不一定向后移动，但j一定向后移动一位，共计n-1次迭代，每次常数时间，累计O(n)时间
- ==**前提是有序向量**==
- 5 8 13 不再是一步一步前移，而是直接一步到位

### 二分查找（有序向量查找算法）

- 复习无序向量查找

![image-20220727211241379](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D2-1 001.png)

- 统一接口

```c++
template <typename T>//查找算法统一接口， 0 <= lo < hi <= _size
Rank Vector<T>::search(T const & e, Rank lo, Rank hi)const{
    return (rand() % 2)?//按各50%的概率随机选用
        binSearch(_elem, e, lo, hi)//二分查找算法
        : fibSearch(_elem, e, lo, hi)//Fibonacci查找算法
}//实际应用中可以在不同算法中选择其一
```

- 处置特殊情况：目标元素不存在？目标元素同时存在多个？——>语义约定
- 语义约定：应该便于有序向量自身的维护：
  - 即使查找失败，也应给出新元素适当的插入位置
  - 若允许重复元素，则每一组也需按其插入的次序排列
- **约定**：在有序向量区间V[lo, hi)中，确定==不大于e的最后一个==元素（秩）
  - 若-∞ < e < V[lo] ，则返回==lo-1==（左侧哨兵）
  - 若V[hi - 1]  < e < +∞，则返回==hi-1==（末元素 = 右侧哨兵左邻）

![image-20220727213048966](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D2-3 001.png)

#### 版本A（Binary Search）

- 原理：减而治之

  以任一元素x=S[mi]为界，都可将待查找区间分为三部分：S[lo, mi) <= S[mi] <= S(mi, hi)

  - 只需将目标元素e与x做一一比较，即可分三种情况继续处理：

  1. e < x：则e若存在必属于左侧子区间S[lo, mi)，故可递归深入

  2. x < e：则e若存在必属于右侧子区间S(mi, hi)，故可递归深入

  3. e = x：已在此处命中，可随即返回

  - 二分（折半）策略：轴点mi总是取作==中点==——每经过至多两次比较，或者能够命中，或者能将问题==规模缩减一半==

![image-20220728101707435](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D2-5 001.png)

- 实现

```c++
template <typename T>//在有序向量区间[lo, hi)内查找元素e
static Rank binSearch(T* A, T const& e, Rank lo, Rank hi){
    while(lo <hi){//每步迭代可能要做两次比较判断，有三个分支
        Rank mi = (lo + hi) >> 1;//以中点为轴点
        if(e < A[mi])//深入前半段[lo, mi)继续查找
            hi = mi;
        else if (A[mi] < e)//深入后半段(mi, hi)继续查找
            lo =  mi;
        else
            return mi;//在mi处命中
    }
    return -1;//查找失败
}
```

- 实例与复杂度

![image-20220728102521605](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D2-6 001.png)

线性递归：T(n) = T(n/2) + O(1) = O(logn) （O(1)指常数次比较），大大优于find()顺序查找O(n)

递归跟踪：轴点总取中点，递归深度O(logn)；各递归实例均耗时O(1)

- 更为精细地评估查找算法的性能——考察关键码的比较次数，即查找查找长度（search length）
- 通常，需分别针对成功与失败查找，从最好、最坏、平均等角度评估 O(1.50 logn)

![image-20220728112623659](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D2-7 001.png)

#### Fibonacci Search

- 二分查找版本A效率仍有改进余地，转向左、右分支前的关键码==比较次数==不等（向左1向右2），而递归深度却相同
- 若能通过==递归深度==的不均衡，对==转向成本==的不均衡进行==补偿==，平均查找长度能进一步缩短（成本低的希望更多地做，成本高的更少地做）<img src="D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D3-1 001.png" alt="image-20220728112036429" style="zoom: 50%;" />

- 实现方法：利用Fibonacci数，在黄金分割点切割

  设有序向量长度n = ==fib(k) - 1==（某个Fibonacci数-1），则可取mi = fib(k - 1) - 1；前、后子向量长度分别为==fib(k - 1) - 1==、==fib(k - 2) - 1==，依然保持某个Fibonacci数-1的形式

![image-20220728113245605](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D3-1 002.png)

```c++
template <typename T>// 0<= lo <= hi <= _size
static Rank fibSearch(T* A, T const & e, Rank lo, Rank hi){
    Fib fib(hi - lo);//用O(log_Φn) = O(log_Φ(hi-lo))时间创建Fib数列
    while(lo < hi){//判断当前lo和hi构成合法区间
        while(hi - lo < fib.get())
            fib.prev();//通过向前顺序查找，确定形如Fib(k)-1的轴点（分摊O(1)）
        Rank mi = lo + fib.get() - 1;//按黄金比例切分
        if (e < A[mi])
            hi = mi;//深入前半段[lo, mi)继续查找
        else if
            (A[mi] < e)
            lo = mi + 1;//深入后半段(mi, hi)继续查找
        else
            return mi;//在mi处命中
    }
    return -1;//查找失败
}
```

```c++
//fib函数补充
class Fib { //Fibonacci数列类
private:
    Rank f, g; //f = fib(k - 1), g = fib(k)。均为int型，很快就会数值溢出
public:
    Fib ( Rank n ) //初始化为不小于n的最小Fibonacci项
    { f = 1; g = 0; while ( g < n ) next(); } //fib(-1), fib(0)，O(log_phi(n))时间
    Rank get()  { return g; } //获取当前Fibonacci项，O(1)时间
    Rank next() { g += f; f = g - f; return g; } //转至下一Fibonacci项，O(1)时间
    Rank prev() { f = g - f; g -= f; return g; } //转至上一Fibonacci项，O(1)时间
};
```



- Fibonacci查找的ASL（average search length），（在常系数的意义上）优于二分查找
  - 举例
![image-20220728114003760](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D3-2 001.png)

查找最优

- 通用策略：对于任何A[0, n)，总是选取A[λn]做为轴点，0≤λ<1

  二分查找对应于λ = 0.5，Fibonacci查找对应于λ = Φ = 0.6180339...

![image-20220728160324036](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D3-4 001.png)

注：递推式：平均查找长度的两种记法，左侧：以log~2~n为渐进复杂度，再配一系数α(λ)：右侧：假设所有元素出现概率相同，每一个区段进入的概率等于区段的长度

#### 版本B（Binary Search）

- 改进思路：解决二分查找中左右分支转向代价不平均的问题

  每次迭代（或每个递归实例）仅做==1次==关键码比较，所有分支只有2个方向，而不是3个

- 轴点mi取作中点，则查找每深入一层，问题规模也缩减一半

  1. ==e < x==：则e若存在必属于左侧子区间S[lo, mi)，故可递归深入
  2. ==x <= e==：则e若存在必属于右侧子区间S[mi, hi)，故可递归深入

  只有当元素数目hi - lo = 1时，才判断该元素是否命中，不能及时判定在当前位置已经命中的情况

![image-20220728173319547](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D4-1 001.png)

- 实现

```c++
template <typename T>//在有序向量区间[lo, hi)内查找元素e
static Rank binSearch(T* A, T const& e, Rank lo, Rank hi){
    while(1 < hi - lo){//有效查找区间宽度缩短至1时，算法才会终止
        Rank mi = (lo + hi) >> 1;//以中点为轴点，经比较后确定深入
        (e < A[mi]) ? hi = mi : lo = mi;//[lo, mi)或[mi, hi)
    }//出口时hi = lo + 1，查找区间仅含一个元素A[lo]
    return (e == A[lo]) ? lo : -1;//返回命中元素的秩或者-1
}//相对于版本A，最好（坏）情况下更坏（好）；各种情况下的SL更加接近，整体更趋稳定（好坏性能差异不大）
```

#### 版本C（功能、语义、性能都近乎完美的算法）

- 以上二分查找以及Fibonacci查找算法均未严格兑现search()接口的语义约定：返回==不大于e==的==最后一个元素==

- 实现

```c++
template <typename T>//在有序向量区间[lo, hi)内查找元素e
static Rank binSearch(T* A, T const& e, Rank lo, Rank hi){
    while(lo < hi){//不变性：A[0, lo) <= e < A[hi, n)
        Rank mi = (lo + hi) >> 1;//以中点为轴点，经比较后确定深入
        (e < A[mi]) ? hi = mi : lo = mi + 1;//[lo, mi)或[mi, hi)
    }//出口时，A[lo = hi]为大于e的最小元素
    return --lo;//lo - 1即为不大于e的元素的最大秩
}
```

- 与版本B区别
  - 待查找区间宽度缩短至==0==而非==1==时，算法才结束
  - 转入右侧子向量时，左边界取作==mi + 1==而非==mi==——（A[mi]不会被遗漏）
  - 无论成功与否，返回的秩严格符合接口的语义约定

- 正确性分析
  - 单调性显然
  - 不变性

![image-20220728200919898](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-D4-5 001.png)

左侧小于等于e，右侧严格大于e。经过一次迭代，无论是向左还是向右，A[mi]并入的操作始终是安全的，不变性始终成立

最终缩小到宽度为0的区间（准确说是分界线），分界线左侧不大于e，右侧严格大于e，从命中角度讲，分界线左侧那个元素元素（lo - 1）



## 排序算法

排序器：统一入口

```c++
template <typename T>
void Vector<T>::sort(Rank lo, Rank hi){//区间[lo, hi)
    switch(rand() % 5){//可视具体问题的特点灵活选取或扩充
        case 1 : bubbleSort(lo, hi); break;//起泡排序
        case 2 : selectionSort(lo, hi); break;//选择排序（详见习题）
        case 3 :mergeSort(lo, hi); break;//归并排序
        case 4 :heapSort(lo, hi); break;//堆排序（第10章）
        default:quickSort(lo, hi); break;//快速排序（第12章）
    }
}//在此统一接口下，具体算法不同实现将在后续陆续补充，本章讲解case 1 3
```

### 起泡排序

[起泡排序算法](#01-d迭代计算复杂度：级数求和)

```c++
template <typename T>
void Vector<T>::bubbleSort(Rank lo, Rank hi)
{while (!bubble(lo, hi));}//逐趟做扫描交换，直至全部有序。bubble为考察介于lo hi之间相邻元素的函数
```

![image-20220728202346459](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-E-1 001.png)

- 改进1：其中无序元素中（绿色）是否存在有序（红色）的部分？

  一个区间有序——当且仅当任意相邻元素对顺序，而在前一次迭代中已经做过类似检查。

  不妨在每一次检查中记录一下，是否曾经真的存在逆序元素，即在当下扫描交换中是否曾经做过一次扫描交换，如果没有，则已经有序。

```c++
template <typename T> bool Vector<T>::bubble(Rank lo, Rank hi){
    bool sorted = true;//整体有序标志
    while(++lo < hi)//自左向右，逐一检查各对相邻元素
        if(_elem[lo - 1] > _elem[lo]){//若逆序，则
            sorted = false;//意味着尚未整体有序，并需要
    		swap(_elem[lo - 1], _elem[lo];})//交换
        }
    return sorted;//返回有序标志
}
```

<img src="D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-E-2 001.png" alt="image-20220728215552701" style="zoom: 33%;" />

- 改进2：即时检测出实际需要排序元素的区间长度，从n^1.5^ 到n^1^转换

  - 反例：后缀已经有序，仅前缀r个元素无序

  - 至多经过前缀元素数次扫描交换，每趟扫描交换实质是<u>让前缀中元素依次就位，直到前缀中元素也完全就位</u>

    多余出来的时间消耗在后缀中已经就位元素的扫描交换

![image-20220728205556272](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-E-3 001.png)

上图中取r = n^0.5^

```c++
template <typename T>
void Vector<T>::bubbleSort(Rank lo, Rank hi)
{while (lo < (hi = bubble(lo, hi)));}//逐趟做扫描交换，直至全部有序

template <typename T> Rank Vector<T>::bubble(Rank lo, Rank hi){
    Rank last = lo;//最右侧的逆序对初始化为[lo - 1, lo]
    while(++lo < hi)//自左向右，逐一检查各对相邻元素
        if(_elem[lo - 1] > _elem[lo]){//若逆序，则
            last = lo;//更新最右侧逆序对位置记录，并
    		swap(_elem[lo - 1], _elem[lo];})//交换
        }
    return last;//返回最右侧逆序对位置
}//前一版本中的逻辑型标志stored改为秩last
```

<center class="half">    <img src="D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-E-4 001.png" width="45%"/>    <img src="D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-E-4 002.png" width="30%"/> </center>

三角形O(n) + O(n)，总体不过O(n)，并且可能多次出现上述情况

但是最坏情况依然需要O(n^2^)

#### 综合评价

- 效率最好O(n)，最坏O(n^2^)

- 输入含重复元素时，算法的==稳定性==（stability）是更为细致的要求：即重复输入元素在输入、输出序列中的相对次序是否保持不变

![image-20220728220227600](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-E-5 001.png)

- 起泡排序是稳定的：

  - 起泡排序中，元素a和b相对位置发生变化只有一种可能：

    经分别与其他元素交换，二者相互==接近==直至==相邻==

    在接下来一轮扫描交换中，二者因==逆序==而==交换==位置

  - 在if语句中，_elem[lo - 1] 和 _elem[lo]交换条件是严格逆序的，<u>相等情况不会交换</u>

### 归并排序

如果采用常规的基于比较式的算法【C . B . A(comparison based algorithm 例如：插入、冒泡、归并、快速)】都会存在下界Ω[nlogn]

- 原理：分治策略

  //==向量==与==列表==通用

  1. 序列一分为二	//O(1)

  2. 子序列递归排序	//2 x T(n/2)

  3. 合并有序子序列	//O(n)

- 实例

![image-20220728221507715](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-F-1 001.png)

- 归并排序运行时间应该为O(nlogn)

  递推关系：T(n) = 2 x T(n/2) + O(n)——（+O(n)是合并需要的）
  
- 实现：

```c++
template <typename T>
void Vector<T>::mergeSort(Rank lo, rank hi){
    if (hi - lo < 2) return;//单元素区间自然有序
    int mi = (lo + hi) >> 1;//否则以中点为界
    mergeSort(lo, mi);//对前半段排序
    mergeSort(mi, hi);//对后半段排序
    merge(lo, mi, hi);//归并
}
```

![image-20220809134459434](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-F-3 001.png)

归并排序利用到二路归并中的一种特例，参与归并的两个序列B、C实际来自同一向量A，不过是通过三个界桩lo mi hi联合定义的

```c++
template <typename T> void Vectot<T>::merge(Rank lo, Rank mi, Rank hi){
    T* A = _elem + lo;//合并后的向量A[0, hi - lo) = _elem[lo, hi)
    int lb = mi - lo; T* B = new T[lb];
    //申请一段长度lb的空间，前子向量B[0, lb) = _elem[lo, mi)
    for (Rank i = 0; i < lb; B[i] = A[i++]);//复制A前半部分到前子向量B
    int lc = hi - mi; T*C = _elem + mi;
    //后子向量[0, lc) = _elem[mi, hi)，不需要另辟空间进行缓存
    for(Rank i = 0, j = 0, k = 0; (j < lb) || (k < lc); ){//B[j]和C[k]中小者转至A的末尾
        if((j < lb) && (lc <= k || (B[j] <= C[k])))
            A[i++] = B[j++];//C[k]已无或不小
        if((k < lc) && (lb <= j || (C[k] < B[j])))
            A[i++] = C[k++];//B[j]已无或更大
    }//注：该循环实现紧凑，就效率而言，不如拆分处理
	delete [] B;//释放临时空间B
}
```

![image-20220811135807674](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-F-4 001.png)

- 正确性：内容不会发生覆盖

![image-20220811140941791](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-F-5 001.png)![image-20220811140913574](D:\Fudan复旦大学\fdu\课程\大二上\数据结构\自学笔记\图片\02-F-5 002.png)

- 复杂度

  - 算法运行时间主要消耗于for循环，共有两个控制变量

  - 初始：j = 0，k = 0

    最终：j = lb，k = lc

    即：j + k = lb + lc = hi - lo =n

  - 每迭代一次，j，k至少一个会jiay

  - merge()归并总体迭代不超过n次，累计只需要线性时间（T(n) = 2 x T(n/2) + O(n)——O(n)出处）

  - 该结论与归并排序算法Ω(nlogn)并不矛盾——因为此处BC均为各自有序

- 注：待归并的子序列不必等长
- 该算法及结论也适用于另一类序列——列表






------

## 线性表

### 线性表

- 定义由零个或多个数据元素组成的有限序列。

  - 是一个序列
  - 若元素存在多个，则<u>第一个元素无前驱，最后一个元素无后继</u>，其他元素都<u>有且只有一个前驱和后继</u>
  - 线性表是有限的，所处理的元素都是有限的

- 若将线性表记为（a1,...ai-1,ai,ai+1,...an），则表中ai-1领先于ai,ai领先于ai+1,ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素

  - n定义为线性表的长度，n=0时为空表

#### 数据类型
- 指一组性质相同的值的集合及定义在此集合上的一些操作的总称

  - 例如C语言中，可分为两类【原子类型：不可再分解的基本类型。整型、浮点型、字符型】【结构类型：由若干个类型组合而成，可再分解。整型数组】

- 抽象数据类型：把数据类型和相关操作捆绑在一起

  - 指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。
  - 抽象的意义在于数据类型的数学抽象特性，不仅指那些已经定义并实现的数据类型，还可以是计算机编程者在设计软件程序时自己定义的数据类型

- 描述抽象数据类型标准格式
  - ADT 抽象数据类型名
  - Data 数据元素之间逻辑关系的定义
  - Operation 操作
  - endADT

# 7.8

### 线性表的抽象数据类型

- 线性表抽象数据类型定义
  - ADT：线性表（List）
  - DATA：线性表的数据对象集合为{a1,a2...an}，每个元素的类型均为DataType。其中第一个元素无前驱，最后一个元素无后继，其他元素都有且只有一个前驱和后继元素。数据元素之间是一对一的关系。
  - 线性表基本运算Operation：
    - InitList（*L）：初始化操作，建立一个空的线性表L
    - ListEmpty（L）：判断线性表是否为空表，若线性表为空，返回true，否则返回false
    - ClearList（*L）：将线性表清空
    - GetElem（L，i，*e）：将线性表L中的第i个位置元素值返回给e
    - LocateElem（L，e）：在线性表L中查找与给定值e相等的元素，查找成功返回该元素在表中的序号（从1开始的），否则返回0表示失败
    - ListInsert（*L，i，e）：在线性表L中第i个位置插入新元素e
    - ListDelete（* L，i，*e）：删除线性表L中第i个位置元素，并用e返回其值
    - ListLength（L）：返回线性表L元素的个数
  - endADT

### 线性表的顺序存储结构

- 线性表顺序存储结构定义：用一段地址连续的存储单元依次存储线性表的数据元素。

- 线性表顺序存储的结构代码：

  ```c
  #define MAXSIZE 20
  typedef int ElemType;
  typdef struct
  {
  	ElemType data[MAXSIZE];
  	int length; //线性表当前长度
  }SqList;
  //此处封装了一个结构，实际上就是对数组进行封装，增加了
  当前长度的变量
  ```

- 顺序存储结构封装属性（以上为例）：

  - 存储空间的起始位置：数组data，其存储位置就是线性表存储空间的存储位置
  - 线性表的最大存储容量：数组的长度MAXSIZE
  - 线性表的当前长度：length

- 地址计算方法

  - 假设Elemype占用c个存储单元（字节），线性表中第i+1个数据和第i个数据元素的存储位置关系：
    LOC（ai+1）= LOC（ai）+c			LOC（ai）= LOC（a1）+（i-1）*c
  - 存储时间性能O（1）——通常称为随机存储结构

- 获取元素操作

  ```c
  #define OK 1
  #define ERROR 0
  //Status 是函数的类型，值为结果状态代码
  //初始条件：顺序线性表L已存在，1<=i<=ListLength(L)
  //操作结果：用e返回L中第i个数据元素的值
  typedef int Status;
  Status GetElem(SqList L, int i, ElemType *e)
  {
      if(L.length == 0|| i < 1 || i > L.length)
      {
          return ERROR;
      }
      *e = L.data(i - 1);
      return OK;
  }
  ```

- 插入操作

  ```c
  //思路
  //如果插入位置不合理，抛出异常
  //如果线性表长度大于等于数组长度，则抛出异常或者动态增加数组容量；
  //从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置
  //将要插入的元素填入位置i
  //线性表长+1
  #define OK 1
  #define ERROR 0
  typedef int Status;
  Status ListInsert(SqList *L, int i, ElemType e)
  {
      int k;
      if(L->length == MAXSIZE)//顺序线性表已满
      {
          return ERROR;
      }
      if(i < 1 || i > L->length + 1)//顺序线性表已满 或i不在范围内
      {
          return ERROR;
      }
      if(i <= L->length )//插入数据位置不在表尾
      {
          for(k = L->length - 1; k >= i - 1; k--)
          {
              L->data[k+1] = L->data[k];
          }
      }
      L->data[i-1] = e;
      l->length++;
      
      return OK;
  }
  ```

# 7.10

  

- 删除操作

  ```c
  //思路
  //如果删除位置不合理，抛出异常
  //取出删除元素
  //从删除位置开始遍历到最后一个元素的位置，分别将它们都向前移动一个位置
  //表长-1
  #define OK 1
  #define ERROR 0
  typedef int Status;
  Status ListDelete(Sqlist *L, int i, ElemType *e)
  {
      int k;
      if(L->length == 0)
      {
          return ERROR;
  	}
      if (i < 1 || i > L->length)
      {
          return ERROR;
      }
      *e = L->data[i-1];
      if(i < L->length)
      {
          for(k = i; k < L->length; k++)
          {
              L->data[k-1] = L-data[k];
          }
      }
      L->length--;
      return OK;
  }
  ```
  
  
  
- 线性表顺序存储结构优缺点：

  - 特点：存储、读取数据，时间复杂度O（1）；插入、删除数据，时间复杂度O（n）。适合元素个数稳定，不经常插入删除数据，更多是存取数据
  - 优点
    - 无须为表示表中元素之间的逻辑关系增加额外的存储空间
    - 可以快速地存取表中任意位置的元素
  - 缺点：
    - 插入和删除操作需要移动大量元素
    - 线性表长度变化较大时，难以确定存储空间的容量
    - 容易造成存储空间的碎片

### 线性表链式存储结构

- 线性表链式存储结构定义：用任意的存储单元存储线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置（所占空间大小和位置不需要预先分配划定，可根据系统情况和实际需求即时生成）。除了**<u>要存储数据元素信息，还要存储它的后继元素的存储地址</u>**（指针）。存储数据元素信息的域称为<u>**数据域**</u>，存储直接后继位置的域称为**<u>指针域</u>**，两部分信息组成数据元素称为存储映像，称为结点（Node）。n个结点链接成一个链表，即为线性表的链式存储结构。

#### 单链表

- 单链表 

  - 头指针

    - 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头节点的指针。
    - 头指针具有标识作用，<u>**常用头指针冠以链表的名字**</u>（指针变量的名字）
    - 无论链表是否为空，头指针均不为空
    - 头指针是链表的必要元素

  - 头结点

    - 为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（也可用来存放链表的长度）
    - 有了头结点，对在第一元素结点前插入节点和删除第一结点操作与其他结点的操作就统一了
    - 头结点不一定是必要的元素

- 单链表存储结构

  ```c
  //c语言中用结构指针来描述
  typedef struct Node
  {
      ElemType data; 		//数据域
      struct Node *Next;	//指针域
  }Node;
  typedef steuct Node *LinkList;
  ```

  - 单链表的读取获取元素操作

    时间复杂度O（n）；不方便使用for循环；核心“工作指针后移”

  
  ```c
  //思路
  //声明一个指针p指向链表第一个结点，初始化j从1开始
  //当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j+1
  //若到链表末尾p为空，则说明第i个元素不存在
  //若查找成功，返回结点p的数据
  #define OK 1
  #define ERROR 0
  Status GetElem(LinkList L, int i, ElemType *e)
  {      
    int j;
    LinkList p;
  
  p = L->next;
  j = 1;
  
  while(p && j < i)
  {
    	p = p->next;
    	++j;
  }
  if(!p || j > i)
  {
    	return ERROR;
  }
  *e = *p->data;
  return OK;
  }
  ```


- 单链表插入操作

  ```c
  //思路
  //声明一个指针p指向链表第一个结点，初始化j从1开始
//当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j+1
  //若到链表末尾p为空，则说明第i个元素不存在
  //若查找成功，在系统中生成一个空结点s
  //将元素e赋值给s->data
  //s->next = p->next;p->next = s->next
  //返回成功
  #define OK 1
  #define ERROR 0
  Status ListInsert(LinkList *L, int i, ElemType e)
  {      
      int j;
      LinkList p, s;
  
  	p = *L;
  	j = 1;
    
  	while(p && j < i)
  	{
      	p = p->next;
      	++j;
  	}
  	if(!p || j > i)
  	{
      	return ERROR;
  	}
      s = (LinkList)mallco(sizeof(Node));
      s->data = e;
      
  	s->next = p->next;
      p->next = s;
      
  	return OK;
  }
  ```
  
- 单链表的删除操作

  ```c
  //思路
  //声明一个指针p指向链表第一个结点，初始化j从1开始
  //当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j+1
  //若到链表末尾p为空，则说明第i个元素不存在
  //若查找成功，将删除节点p->next赋值给q
  //p->next = q->next
  //将q结点中的数据赋值给e返回
  //释放q结点
  #define OK 1
  #define ERROR 0
  Status ListInsert(LinkList *L, int i, ElemType *e)
  {      
      int j;
      LinkList p, q;
  
  	p = *L;
  	j = 1;
    
  	while(p && j < i)
  	{
      	p = p->next;
      	++j;
  	}
  	if(!p || j > i)
  	{
      	return ERROR;
  	}
      q = p->next;
      p->next = q->next;
  
      *e = q->data;
      free(q)
  	return OK;
  }
  ```

- 线性表链式存储结构特点：

  存储、读取数据、插入、删除数据，时间复杂度都是O（n）。连续插入若干个元素，顺序存储结构每次都是O（n），单链表第一次O（n），接下来都是O（1），单链表适合插入删除数据频繁的操作。

- 单链表的整体创建

  - 单链表整表创建算法思路：
    - 声明一结点p和计数器变量i
    - 初始化一空链表L
    - 让L的头结点指针指向NULL，建立一个带头结点的单链表
    - 循环实现后继结点的赋值和插入
  - 头插法建立单链表
    - 先让新结点的next指向头结点之后
    - 让表头的next指向新节点

  ```c
  void CreateListHead(LinkList *L, int n)
  {
      LinkList p;
      int i;
      
      srand(time(0));
      *L = (LinkList)malloc(sizeof(Node)):
      (*L)->next = NULL;
      
      for(i =0; i < n;i++)
      {
          p = (LinkList)malloc(sizeof(Node));
          p->data = rand()%100 + 1;
          p->next = (*L)->next;
   		(*L)->next = p;       
      }
  }
  ```

  - 尾插法建立单链表

  ```c
void CreateListTail(LinkList *L, int n)
  {
      LinkList p, r;
      int i;
      
      srand(time(0));
      *L = (LinkList)malloc(sizeof(Node)):
      (*L)->next = NULL;
      r = *L;
      
      for(i =0; i < n;i++)
      {
          p = (LinkList)malloc(sizeof(Node));
          p->data = rand()%100 + 1;
          r->next = p;
   		r = p;       
      }
      r->next = NULL
  }
  ```
  
- 单链表的整表删除

  - 声明结点p和q
  - 将第一个结点赋值给p，下一个结点赋值给q
  - 循环执行释放p和将q赋值给p的操作

  ```c
  Status ClearList(LinkList *L)
  {
      LinkList p, q;
      p = (*L)->next;
      while(p)
      {
          q = p->next;
          free(p);
          p = q;
      }
      (*L)->next = NULL;
  }
  ```

#### 单链表结构（链式存储）与顺序存储结构优缺点比较

- 存储分配方式
  - 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
  - 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素
- 时间性能：
  - 查找
    - 顺序存储结构O（1）
    - 单链表O（n）
  - 插入和删除
    - 顺序存储结构需要平局移动表长一半的元素，时间为O（n）
    - 单链表在计算出某位置的指针后O（n），插入和删除时间仅为O（1）
  - 空间性能
    - 顺序存储结构需要预分配存储空间，分大容易造成空间浪费，分小容易发生溢出
    - 单链表无需预先分配存储空间，只要有就可以分配，元素个数不受限制

- 结论
  - 若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构
  - 若需要频繁插入和删除时，宜采用单链表结构

#### 静态链表

- 用数组描述的链表叫做静态链表，实现方法：游标实现法

```c
#结构数组
#define MAXSIZE 1000
typedef struct
{
	ElemType data;
	int cur
}Component, StaticLinkList[MAXSIZE]
```

| 游标 | 5    | 2    | 3    | 4    | 5    | 6    | 7    | ...  | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数据 |      | A    | C    | D    | E    |      |      | ...  |      |
| 下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | ...  | 999  |

下标为0的元素的游标指向数组中没有存放数据的第一个元素，最后一个元素的游标指向第一个有数据的元素下标。a[0]->cur指向尾部 a[MAX]->cur指向头部

- 静态链表初始化

```c
Status InitList(StaticLinkList space)
{
    int i;
    for(i = 0; i < MAXSIZE - 1; i++)
    {
        space[i].cur = i + 1;
    }        
    space[MAXSIZE - 1].cur = 0;
    return OK;
}
```

- 注：
  - 对数组的第一个和最后一个元素做特殊处理，data不存放数据
  - 通常把未使用的数组元素称为备用链表
  - 数组第一个元素（下标为0）的cur存放备用链表的第一个节点的下标
  - 数组最后一个元素（下标为MAXSIZE-1）的cur存放第一个有数值的元素的下标，其作用相当于单链表中头结点

- 静态链表的插入操作

  ```c
  /* 在静态链表L中第i个元素之前插入新的数据元素e */
  Status ListInsert( StaticLinkList L, int i, ElemType e )
  {
      int j, k, l;
  
      k = MAX_SIZE - 1;    // 数组的最后一个元素
      if( i<1 || i>ListLength(L)+1 )
      {
          return ERROR;
      }
  // 获取空闲的第一个分量的下标
      j = Malloc_SLL(L);
  /*
  int Malloc_SLL(StaticLinkList space)
  {
      int i = space[0].cur;    //获取当前数组的第一个元素中存放的可用下标
      if (space[0].cur)    //若是下标可用，若是指向0，数组空间全部用尽
          space[0].cur = space[i].cur;　　//会自动更新0处的空闲分量游标
      return i;
  */
      if( j )
      {
          L[j].data = e;
          // 1是新插入的元素，即B
          // 插入到第二个元素之前，所以是i-1
          // i=2，循环执行1次
          for( l=1; l <= i-1; l++ )
          {
              // L[k],l[最后一个元素]，游标指向第一个元素，赋值给K
  
              k = L[k].cur;
          }
  
      // 即2取出来，存放到L[j]
          L[j].cur = L[k].cur;
          // j5,存放到L[k]
          L[k].cur = j;
  
          return OK;
      }
      return ERROR;
      // 获得空闲分量的下标：
  int Malloc_SLL(StaticLinkList space)
  {
  int i = space[0].cur;
  if( space[0].cur )
  space[0].cur = space[i].cur;
     // 把它的下一个分量用来作为备用。
  return i;
  }
  
  }
  ```

  

- 静态链表的删除操作
- 静态链表











# 难懂

p 24 01-E-7 Max 2  [Max 2](#分而治之:) 退化情况怎么写
p 29 01-F-5 fib()  [fib递归改进](#解决方法A（记忆：memoization）)  时间复杂度是O(n)吗？

p 32 01-F-8，9 LCS 图解！！

p 50 02-C-7，[唯一化改进](#唯一化) 

p 51 02-C-8 遍历 函数指针、函数对象机制 遍历功能练习

p 63 02-D2-7 查找长度 && p 65 Fibonacci查找的ASL//详见教材，习题解析

p70 02-D4-3 版本C，我大受震撼，难以想象天才如何设计出这样的算法